"""
Canny算子是用于边缘检测的经典算法，主要由以下五个步骤组成：

    高斯滤波：首先对原始图像进行高斯滤波，以消除或降低图像中的噪声，同时保留图像的结构信息。

    计算梯度幅值和方向：使用Sobel算子或其他类似算子计算每个像素点的梯度幅值和方向。梯度方向指示了图像中变化最为剧烈的区域，即可能的边缘位置。

    非极大值抑制：在这个阶段，只保留那些梯度幅值在其局部区域内达到最大值的像素点作为边缘点。这种方法可以去除背景噪声并简化边缘结构。

    双阈值处理：设定一个较低和高阈值，将梯度幅值与其相比较。如果某个像素点的梯度幅值超过了高阈值，则保留该点；如果低于低阈值，则忽略该点。这样，可以区分出强边缘、弱边缘以及非边缘像素点。

    边缘连结：对于弱边缘像素点，将其与相邻的强边缘像素点相连，形成更清晰的边缘轮廓。这种连结策略有助于消除断开的边缘线，使边缘更加连续和精确。

综上所述，Canny算子的基本原理是通过一系列的数学运算和参数调整，从图像中分离出明显的边缘特征，同时滤除不必要的噪声和伪边缘。




canny
对输入图像进行灰度化处理。
对灰度图像进行高斯滤波，以平滑图像并去除噪声。
对滤波后的图像使用Sobel算子计算梯度幅值和方向。
对梯度幅值进行非极大值抑制，以压缩边缘带宽。
对压缩后的边缘带宽使用滞后阈值进行二值化，得到二值化图像。
对二值化图像进行连接操作，将断开的边缘进行连接，得到最终的边缘图像。


较低的阈值可以检测到较弱的边缘，而较高的阈值可以去除较弱的边缘


"""

import cv2
import numpy as np

# 读取一张图片
image = cv2.imread("9.png")

# 使用Canny函数进行边缘检测
edges = cv2.Canny(image, 100, 200)

# 显示结果
cv2.imshow('Original', image)
cv2.imshow('Canny Edges', edges)
cv2.waitKey()
