"""
https://mp.weixin.qq.com/s?__biz=MzU0NjgzMDIxMQ==&mid=2247569389&idx=4&sn=7f93a257c597821bb55da3e2637a3f3d&chksm=fb542d01cc23a4178b83617a01e933494ca6274dd2086baf2bd0354ac30637cc9af674458116&scene=27
在Python中，按照更新对象的方式，我们可以将对象分为2大类：可变数据类型和不可变数据类型。

    不可变数据类型：数值、字符串、布尔值。不可变对象就是对象的身份和值都不可变。新创建的对象被关联到原来的变量名，旧对象被丢弃，垃圾回收器会在适当的时机回收这些对象。
它在内存中的位置是不变的。 这个变量在计算机内存中的位置是不变的，只是换了一个名字来存放.当我们对字符串、数值型、布尔值的数据改变变量名，并不会影响到数据在内存中的位置。
    可变数据类型：列表、字典、集合。所谓的可变指的是可变对象的值可变，但是身份是不可变的。
虽然是相同的数据，但是变量名字不同，内存中仍然会开辟新的内存地址来进行存放相同的数据



在Python语言中，每个对象都会在内存中申请开辟一块新的空间来保存对象；对象在内存中所在位置的地址称之为引用。

可以说，我们定义的变量名实际上就是对象的地址引用。引用实际上就是内存中的一个数字地址编号。在使用对象的时候，只要知道这个对象的地址，我们就可以操作这个对象。

因为这个数字地址不太容易记忆，所以我们使用变量名的形式来代替对象的数字地址。在Python中，变量就是地址的一种表示形式，并不会开辟新的存储空间。
在Python中，每次赋值都会开辟新的内存地址来存放数据，比如我们同时存放一个列表[1,2,3]，即使数据是相同的，但是内存地址却不同：
如果我们对一个变量多次赋值，其内存是会变化的：
将一个变量赋值给另一个变量，其实它们就是同一个对象：数据相同，在内存中的地址也相同：
如果是列表中嵌套着另外的列表，那么当改变其中一个列表的时候，另一个列表中的也会随着改变：


在Python中进行拷贝之前，我们需要导入模块：

import copy

⚠️浅拷贝只是拷贝数据的第一层，不会拷贝子对象。
不可变类型的浅拷贝

如果只是针对不可变的数据类型（字符串、数值型、布尔值），浅拷贝的对象和原数据对象是相同的内存地址：  针对不可变类型的浅拷贝，只是换了一个名字，对象在内存中的地址其实是不变的。

不存在嵌套类型的可变类型数据（列表、字典、集合）：    列表本身的浅拷贝对象的地址和原对象的地址是不同的，因为列表是可变数据类型。
    列表中的元素（第1个元素为例）和浅拷贝对象中的第一个元素的地址是相同的，因为元素本身是数值型，是不可变的。
    字典中也存在相同的情况：字典本身的内存地址不同，但是里面的键、值的内存地址是相同的，因为键值都是不可变类型的数据。
    在可变类型的数据中，如果存在嵌套的结构类型，浅拷贝只复制最外层的数据，导致内存地址发生变化，里面数据的内存地址不会变




深拷贝不同于浅拷贝的是：深拷贝会拷贝所有的可变数据类型，包含嵌套的数据中的可变数据。深拷贝是变量对应的值复制到新的内存地址中，而不是复制数据对应的内存地址。
针对不可变数据类型的深浅拷贝，其结果是相同的。

    深拷贝对最外层数据是只拷贝数据，会开辟新的内存地址来存放数据。
    深拷贝对里面的不可变数据类型直接复制数据和地址，和可变类型的浅拷贝是相同的效果。

对整个存在嵌套类型的数据进行深浅拷贝都会发生内存的变化，因为数据本身是可变的。
图片
我们查看第一个元素1的内存地址，发生三者是相同的，因为1是属于数值型，是不可变类型。
图片
我们查看第三个元素即里面嵌套列表的内存，发现只有深拷贝是不同的，因为这个嵌套的列表是可变数据类型，深拷贝在拷贝了最外层之后还会继续拷贝子层级的可变类型。
我们查看嵌套列表中的元素的内存地址，发现它们是相同的，因为元素是数值型，是不可变的，不受拷贝的影响。

不存在嵌套结构
当元组中不存在嵌套结构的时候，元组的深浅拷贝是相同的效果：

存在嵌套结构
当元组的数据中存在嵌套的可变类型，比如列表等，深拷贝会重新开辟地址，将元组重新成成一份。

   is()比较对象的标识；==运算符比较两个对象的值（对象中保存的数据）。在实际的编程中，我们更多关注的是值，而不是标识本身。
我们先创建了一个对象v3，然后将他赋值给另一个对象v4，其实它们就是相同的对象，所以标识（内存地址）是相同的，只是它们的名字不同而已。

通过大量的例子，我们得出结论：

    在不可变数据类型中，深浅拷贝都不会开辟新的内存空间，用的都是同一个内存地址。
    在存在嵌套可变类型的数据时，深浅拷贝都会开辟新的一块内存空间；同时，不可变类型的值还是指向原来的值的地址。

不同的是：在嵌套可变类型中，浅拷贝只会拷贝最外层的数据，而深拷贝会拷贝所有层级的可变类型数据。
"""